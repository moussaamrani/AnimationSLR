@inproceedings{10.1007/978-3-031-35361-1_9,
	abstract = {This tool paper presents : a methodology and a programming framework for computer-aided design of structural operational semantics for formal models . This framework includes a set of Scala libraries and a workflow to produce visual and interactive diagrams that animate and provide insights over the structure and the semantics of a given abstract model with operational rules. follows an approach in which theoretical foundations and a practical tool are built together, as an alternative to foundations-first design (“tool justifies theory”) or tool-first design (“foundations justify practice”). The advantage of is that the tool-under-development can immediately be used to automatically run numerous and sizeable examples in order to identify subtle mistakes, unexpected outcomes, and unforeseen limitations in the foundations-under-development, as early as possible. We share two success stories of methodology and framework in our own teaching and research context, where we analyse a simple while-language and a choreographic language, including their operational rules and the concurrent composition of such rules. We further discuss how others can include in their own analysis and Scala tools.},
	author = {José Proença and Luc Edixhoven},
	booktitle = {Coordination Models and Languages},
	doi = {10.1007/978-3-031-35361-1_9},
	month = {jan},
	publisher = {Springer},
	title = {Caos: A Reusable Scala Web Animator of Operational Semantics},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-35361-1_9},
	year = 2023
}

@article{10.1007/s11334-021-00408-4,
	abstract = {One of the promising techniques to address the dependability of a system is to apply, at early design stages, domain-specific languages (DSLs) with execution semantics. Indeed, an executable DSL would not only represent the expected system’s structure, but it is intended to itself behave as the system should run. In order to make executable DSLs a powerful asset in the development of safety-critical systems, not only a rigorous development process is required but the domain expert should also have confidence in the execution semantics provided by the DSL developer. To this aim, we recently developed the Meeduse tool and showed how to bridge the gap between MDE and a proof-based formal approach. In this work, we apply our approach to the Petri-net DSL and we present MeeNET, a proved Petri-net designer and animator powered by Meeduse. MeeNET is built on top of PNML (Petri-Net Markup Language), the international standard ISO/IEC 15909 for Petri-nets, and provides underlying formal static and dynamic semantics that are verified by automated reasoning tools. This paper first presents simplified MDE implementations of Petri-nets applying Java, QVT, Kermeta and fUML that we experimented in order to debug a safety-critical system and summarises the lessons learned from this study. Then, it provides formal alternatives, based on the B method and process algebra, which are well-established techniques allowing interactive animation on the one hand and reasoning about the behaviour correctness, on the other hand.},
	author = {Akram Idani},
	doi = {10.1007/s11334-021-00408-4},
	journal = {Innovations in Systems and Software Engineering},
	keywords = {DSL, Formal methods, B Specification, Animation, Proofs},
	month = {dec},
	number = 4,
	page = {543–566},
	publisher = {Springer},
	title = {Formal model-driven executable DSLs},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s11334-021-00408-4},
	volume = 18,
	year = 2022
}

@article{10.1134/S0361768824700865,
	abstract = {Abstract Geometric algebra is currently considered as a universal mathematical apparatus of computer graphics. Active research, both academic and applied, is being conducted in this area. Due to the applied nature of the research, many results are immediately implemented in the form of computer program code and libraries. One of such libraries is Ganja.js The aim of this paper is to review some capabilities of Ganja.js using the example of projective geometric algebra 
$${{\mathcal{C}}_{{2,0,1}}}(\mathbb{R})$$
 in its dual version. The paper uses the apparatus of linear algebra, elements of projective geometry, and geometric algebra (Clifford and Grassmann algebras). The software tools used are those of JavaScript. Ganja.js implements a mathematical syntax that allows you to define various Clifford algebras, manipulate their elements using algebraic operations, and visualize algebra elements as geometric objects. The created visualizations can be interactive and animated. Even though JavaScript is a completely unusual language for academic mathematical research, Ganja.js can be a useful tool for computation, visualization, and research in geometric algebra.},
	author = {M. N. Gevorkyan and T. R. Velieva and A. V. Korol’kova and D. S. Kulyabov and L. A. Sevast’yanov},
	doi = {10.1134/S0361768824700865},
	journal = {Programming and Computer Software},
	month = {apr},
	number = 2,
	page = {67–82},
	publisher = {Springer},
	title = {Projective Geometric Algebra in Plane and Its Implementation in the Library Ganja.js},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1134/S0361768824700865},
	volume = 51,
	year = 2025
}


@inproceedings{10.1007/978-3-031-66456-4_13,
	abstract = {The aim of this work is to translate railML 3 files to the formal B-method to enable formal verification and validation. railML is an XML-based format designed to facilitate the exchange of information about railway systems. Our approach allows syntactic and semantic validation against predefined and custom rules, using ProB and its integrated B-Rules DSL. In addition, a B-model can be generated to animate the dynamic behaviour of the specification, which can also be used for simulations and statistical tests using SimB . A technique for creating visualisations of the topology using Graphviz is presented. Finally, real-life railML case studies show that the implemented validation process can be effectively applied to complex models and that errors in these models can be successfully detected.},
	author = {Jan Gruteser and Michael Leuschel},
	booktitle = {Engineering of Complex Computer Systems},
	doi = {10.1007/978-3-031-66456-4_13},
	month = {jan},
	publisher = {Springer},
	title = {Validation of railML Using ProB},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-66456-4_13},
	year = 2025
}

@inproceedings{10.1007/978-3-031-85356-2_10,
	abstract = {The design and analysis of security in distributed computing systems raises numerous questions on the tools available for modeling and verification. Particularly, it is difficult to ensure the correctness when using different validation processes in software architecture design. Assuring cross-platform validation manually is labor intensive, expertise dependent, and error prone. This paper proposes an approach for the design and analysis of secure software architecture in the context of a component-port-connector architecture model and message passing communication. We use the Event-B formal method to create the software architecture model and security in successive steps using the refinement process. We also use proof obligations to verify the security of the successive software architecture models. Furthermore, we use the ProB model-checker and animator for the model validation.},
	author = {Loïc Thierry and Brahim Hamid and Jason Jaskolka},
	booktitle = {Verification and Evaluation of Computer and Communication Systems},
	doi = {10.1007/978-3-031-85356-2_10},
	keywords = {formal methods, model-driven engineering, component-based software architecture, security objectives, Event-B, ProB},
	month = {jan},
	publisher = {Springer},
	title = {A Formal Approach for Verifying and Validating Security Objectives in Software Architecture},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-85356-2_10},
	year = 2025
}


@inproceedings{10.1007/978-3-031-63790-2_5,
	abstract = {Petri-nets and their variants (Place/Transition nets, High-Level Petri Nets, etc.) are widely used in the development of safety critical-systems. Their success is related to three major aspects: a formal semantics, a graphical syntax and the availability of verification tools. In our previous work we presented a new vision for the semantic definition of Petri-nets applying a Formal Model-Driven Engineering (FMDE) built on the B method. The approach is powered by Meeduse , a language workbench that we developed in order to formally instrument executable Domain-Specific Languages (xDSLs) by applying a deep embedding technique and the B method. However, because of the abstract nature of the underlying formal models, our deep embedding is suitable for the validation and verification activities at the design stage but not sufficient to generate code for target platforms. This paper advances our previous work with a shallow embedding technique taking benefit of the B method tools in order to safely synthesize executable Petri-net controllers that can be embedded in target platforms.},
	author = {Akram Idani},
	booktitle = {Rigorous State-Based Methods},
	doi = {10.1007/978-3-031-63790-2_5},
	keywords = {B Method, Petri-nets, Verification, Formal MDE},
	month = {jan},
	publisher = {Springer},
	title = {Transpilation of Petri-nets into B},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-63790-2_5},
	year = 2024
}

@article{10.1007/s10270-022-01025-w,
	abstract = {Executable Domain-Specific Languages (xDSLs) allow the definition and the execution of behavioral models. Some behavioral models are reactive, meaning that during their execution, they accept external events and react by exposing events to the external environment. Since complex interaction may occur between the reactive model and the external environment, they should be tested as early as possible to ensure the correctness of their behavior. In this paper, we propose a set of generic testing facilities for reactive xDSLs using the standardized Test Description Language (TDL). Given a reactive xDSL, we generate a TDL library enabling the domain experts to write and run event-driven TDL test cases for conforming reactive models. To further support the domain expert, the approach integrates interactive debugging to help in localizing defects, and mutation analysis to measure the quality of test cases. We evaluate the level of genericity of the approach by successfully writing, executing, and analyzing 247 event-driven TDL test cases for 70 models conforming to two different reactive xDSLs.},
	author = {Faezeh Khorram and Erwan Bousse and Jean-Marie Mottu and Gerson Sunyé},
	doi = {10.1007/s10270-022-01025-w},
	journal = {Software and Systems Modeling},
	keywords = {Reactive executable DSL, Testing, Test description language, Debugging, Mutation analysis},
	month = {jun},
	number = 3,
	page = {819–845},
	publisher = {Springer},
	title = {Advanced testing and debugging support for reactive executable DSLs},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01025-w},
	volume = 22,
	year = 2023
}


@article{10.1007/s12369-021-00768-8,
	abstract = {We present the Dynamic Stack Decider  (DSD), a lightweight open-source control architecture. It combines different well-known approaches and is inspired by behavior trees as well as hierarchical state machines . The DSD allows to design and structure complex behavior of robots as well as software agents while providing easy maintainability. Challenges that often occur in robotics, i.e., a dynamic environment and situation uncertainty, remain well-manageable. Furthermore, it allows fast modifications of the control flow, while providing the state-fullness of a state machine. The approach allows developing software using a simple Domain Specific Language (DSL) which defines the control flow and two types of elements that contain the programmed parts. The framework takes care of executing the demanded portions of the code and gives, due to its stack-like internal representation, the ability to verify preconditions while maintaining a clear structure. The presented software was used in different robotic scenarios and showed great performance in terms of flexibility and structuredness.},
	author = {Martin Poppinga and Marc Bestmann},
	doi = {10.1007/s12369-021-00768-8},
	journal = {International Journal of Social Robotics},
	keywords = {Control architecture, Framework, Behavior, Robots, Agents},
	month = {jan},
	number = 1,
	page = {73–83},
	publisher = {Springer},
	title = {DSD - Dynamic Stack Decider},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s12369-021-00768-8},
	volume = 14,
	year = 2022
}

@article{10.1061/JCEMD4.COENG-15495,
	author = {Shao Y.},
	doi = {10.1061/JCEMD4.COENG-15495},
	journal = {Journal of Construction Engineering and Management},
	month = {feb},
	number = 2,
	title = {Revelation and Enhancement for Pedestrian Evacuation at Metro Station: Metamodeling-Based Simulation Optimization Approach},
	url = {https://api.elsevier.com/content/abstract/scopus_id/85211923123},
	volume = 151,
	year = 2025
}

@inproceedings{10.1007/978-3-031-19756-7_8,
	abstract = {Regarding documentation as anything that supports understanding , we present two test-first scenarios of executable documentation that involve and support different roles during program development through concrete data visualizations. The first is a teaching scenario. Within classical programming, different stages of executable documentation provide faceted layers of self-learning and user-centric diagnostics. Students and teachers benefit from auto-didactic exploration, appropriate diagram syntheses for runtime visualization, and automated test case generation. The latter can be created using reference implementations provided by the teacher but can also be used to foster the dialog between students and tutors. The second scenario introduces a new approach to WYSIWYG GUI editing that is able to render the runtime GUI appearance in real-time within the editor. Using scenario-based test cases, users can seamlessly experience, inspect, and test the GUI while they are editing. The paper discusses the impact of the provided tangible experiences and their role in modern IDEs.},
	author = {Steven Smyth and Jette Petzold and Jonas Schürmann and Florian Karbus and Tiziana Margaria and Reinhard Hanxleden and Bernhard Steffen},
	booktitle = {Leveraging Applications of Formal Methods, Verification and Validation. Software Engineering},
	doi = {10.1007/978-3-031-19756-7_8},
	keywords = {Documentation, Teaching, Test-driven development, Automatic layout, Verification, Web technologies},
	month = {jan},
	publisher = {Springer},
	title = {Executable Documentation: Test-First in Action},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-19756-7_8},
	year = 2022
}



@article{10.1007/s10270-022-01073-2,
	abstract = {Recent results in language engineering simplify the development of tool-supported executable domain-specific modeling languages (xDSMLs), including editing (e.g., completion and error checking) and execution analysis tools (e.g., debugging, monitoring and live modeling). However, such frameworks are currently limited to sequential execution traces and cannot handle execution traces resulting from an execution semantics with a concurrency model supporting parallelism or interleaving. This prevents the development of concurrency analysis tools, like debuggers supporting the exploration of model executions resulting from different interleavings. In this paper, we present a generic framework to integrate execution semantics with either implicit or explicit concurrency models, to explore the possible execution traces of conforming models, and to define strategies for helping in the exploration of the possible executions. This framework is complemented with a protocol to interact with the resulting executions and hence to build advanced concurrency analysis tools. The approach has been implemented within the GEMOC Studio. We demonstrate how to integrate two representative concurrent meta-programming approaches (MoCCML/Java and Henshin), which use different paradigms and underlying foundations to define an xDSML’s concurrency model. We also demonstrate the ability to define an advanced concurrent omniscient debugger with the proposed protocol. The paper, thus, contributes key abstractions and an associated protocol for integrating concurrent meta-programming approaches in a language workbench, and dynamically exploring the possible executions of a model in the modeling workbench.},
	author = {Steffen Zschaler and Erwan Bousse and Julien Deantoni and Benoit Combemale},
	doi = {10.1007/s10270-022-01073-2},
	journal = {Software and Systems Modeling},
	keywords = {Language engineering, Model execution, Model concurrency, Simulation, Concurrent analyses/debugging},
	month = {aug},
	number = 4,
	page = {1319–1340},
	publisher = {Springer},
	title = {A generic framework for representing and analyzing model concurrency},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01073-2},
	volume = 22,
	year = 2023
}

@article{10.3390/app15137062,
	author = {Chen S.},
	doi = {10.3390/app15137062},
	journal = {Applied Sciences Switzerland},
	month = {jul},
	number = 13,
	title = {Vulnerability Assessment Framework for Physical Protection Systems Integrating Complex Networks and Fuzzy Petri Nets},
	url = {https://api.elsevier.com/content/abstract/scopus_id/105010339970},
	volume = 15,
	year = 2025
}


@article{10.1007/s10270-021-00950-6,
	abstract = {Modern software systems are intricate and operate in highly dynamic environments for which few assumptions can be made at design-time. This setting has sparked an interest in solutions that use a runtime model which reflects the system state and operational context to monitor and adapt the system in reaction to changes during its runtime. Few solutions focus on the evolution of the model over time, i.e., its history, although history is required for monitoring temporal behaviors and may enable more informed decision-making. One reason is that handling the history of a runtime model poses an important technical challenge, as it requires tracing a part of the model over multiple model snapshots in a timely manner. Additionally, the runtime setting calls for memory-efficient measures to store and check these snapshots. Following the common practice of representing a runtime model as a typed attributed graph, we introduce a language which supports the formulation of temporal graph queries, i.e., queries on the ordering and timing in which structural changes in the history of a runtime model occurred. We present a querying scheme for the execution of temporal graph queries over history-aware runtime models. Features such as temporal logic operators in queries, the incremental execution, the option to discard history that is no longer relevant to queries, and the in-memory storage of the model, distinguish our scheme from relevant solutions. By incorporating temporal operators, temporal graph queries can be used for runtime monitoring of temporal logic formulas. Building on this capability, we present an implementation of the scheme that is evaluated for runtime querying, monitoring, and adaptation scenarios from two application domains.},
	author = {Lucas Sakizloglou and Sona Ghahremani and Matthias Barkowsky and Holger Giese},
	doi = {10.1007/s10270-021-00950-6},
	journal = {Software and Systems Modeling},
	keywords = {Runtime models, History-awareness, Historic data, Temporal graph queries, Incremental pattern matching, Runtime monitoring, Self-adaptive systems},
	month = {oct},
	number = 5,
	page = {1789–1829},
	publisher = {Springer},
	title = {Incremental execution of temporal graph queries over runtime models with history and its applications},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-021-00950-6},
	volume = 21,
	year = 2022
}



