@article{10.1007/s00371-022-02451-z,
	abstract = {Advances in computational power and numerical simulations have made many complex scientific simulations possible, generating large-scale and complex time-varying data. How we effectively extract and track the features contained in time-varying data play a crucial role in helping scientists recognize and understand the trendsD and dynamic behaviors behind these simulations. Many feature extraction and tracking methods often require the user to initially feed numerous feature data, e.g., a volume into their models for feature extraction, and then track the feature locally by comparing the features at two consecutive time steps. In this paper, we propose a different method to achieve feature extraction and tracking. For feature extraction, our method simply requires the user to label a feature on two slices in the time-varying data, and then, it generates a set of optimized Gaussian mixture model rules that can be used to automatically extract the feature at each time step in the time-varying data. Based on the extracted feature at each time step, our tracking method can create a global tracking graph that will record all possible tracking information of this feature across all time steps and thus achieve a global feature tracking. To demonstrate the effectiveness of our method, we applied several time-varying datasets from scientific simulations to it. Furthermore, to validate our method, we both qualitatively and quantitatively compared its feature tracking results against the ones from two state-of-the-art feature tracking techniques by referring to the ground truth. The experiment results showed that our method could generate the most accurate feature tracking results than the two compared state-of-the-art techniques.},
	author = {Ji Ma and Jinjin Chen and Chang Yang},
	doi = {10.1007/s00371-022-02451-z},
	journal = {The Visual Computer},
	keywords = {Feature extraction and tracking, Time-varying data, Gaussian mixture model rules, Global tracking graph, Volume rendering, Animation},
	month = {may},
	number = 5,
	page = {1869–1892},
	publisher = {Springer},
	title = {Using optimized gaussian mixture model rules and global tracking graph for feature extraction and tracking in time-varying data},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s00371-022-02451-z},
	volume = 39,
	year = 2023
}


@article{10.1007/s11042-022-12307-2,
	abstract = {Game development is a collective process in which a variety of different professionals from different backgrounds collaborate together not only by means of conversational interaction but also collaborative participation, one of which is programming. While collaborative and pair programming solutions exist for text-based programming languages, visual programming has not enjoyed as much attention. These solutions would not only address advanced forms of business communication among team members but could find their use in distance learning, which would have been useful during the pandemic. In our work, we propose a solution for collaborative behavioral animation of NPCs using behavior trees through synchronous and asynchronous modes of collaboration. We conducted a user study with 12 moderately skilled game development university students who were placed in groups of two and engaged in joint fixed behavior tree development tasks using the synchronous and asynchronous modes and auxiliary features of live preview, access and restoration of previous states from behavior tree history, conflict resolution, and instant messaging. Participants also completed a control task where no collaboration was involved and auxiliary features were not available. Feedback form Creativity Support Index, a self-developed questionnaire, and a semi-structured interview were collected. Additionally, task completion times were logged. The results indicate that the two collaborative modes provide expected improvement over the control condition. No significant differences were found between the two collaborative modes. However, the semi-structed interview revealed that the synchronous mode could be useful for quick prototyping, while the asynchronous mode – for most other situations.},
	author = {Md. Yousuf Hossain and Loutfouz Zaman},
	doi = {10.1007/s11042-022-12307-2},
	journal = {Multimedia Tools and Applications},
	keywords = {Behavior tree, Collaboration, Game AI, Game development, Unity engine},
	month = {jan},
	number = 3,
	page = {4671–4708},
	publisher = {Springer},
	title = {NCCollab: collaborative behavior tree authoring in game development},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s11042-022-12307-2},
	volume = 82,
	year = 2023
}

@inproceedings{10.1007/978-3-031-35361-1_9,
	abstract = {This tool paper presents : a methodology and a programming framework for computer-aided design of structural operational semantics for formal models . This framework includes a set of Scala libraries and a workflow to produce visual and interactive diagrams that animate and provide insights over the structure and the semantics of a given abstract model with operational rules. follows an approach in which theoretical foundations and a practical tool are built together, as an alternative to foundations-first design (“tool justifies theory”) or tool-first design (“foundations justify practice”). The advantage of is that the tool-under-development can immediately be used to automatically run numerous and sizeable examples in order to identify subtle mistakes, unexpected outcomes, and unforeseen limitations in the foundations-under-development, as early as possible. We share two success stories of methodology and framework in our own teaching and research context, where we analyse a simple while-language and a choreographic language, including their operational rules and the concurrent composition of such rules. We further discuss how others can include in their own analysis and Scala tools.},
	author = {José Proença and Luc Edixhoven},
	booktitle = {Coordination Models and Languages},
	doi = {10.1007/978-3-031-35361-1_9},
	month = {jan},
	publisher = {Springer},
	title = {Caos: A Reusable Scala Web Animator of Operational Semantics},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-35361-1_9},
	year = 2023
}

@article{10.1007/s11334-021-00408-4,
	abstract = {One of the promising techniques to address the dependability of a system is to apply, at early design stages, domain-specific languages (DSLs) with execution semantics. Indeed, an executable DSL would not only represent the expected system’s structure, but it is intended to itself behave as the system should run. In order to make executable DSLs a powerful asset in the development of safety-critical systems, not only a rigorous development process is required but the domain expert should also have confidence in the execution semantics provided by the DSL developer. To this aim, we recently developed the Meeduse tool and showed how to bridge the gap between MDE and a proof-based formal approach. In this work, we apply our approach to the Petri-net DSL and we present MeeNET, a proved Petri-net designer and animator powered by Meeduse. MeeNET is built on top of PNML (Petri-Net Markup Language), the international standard ISO/IEC 15909 for Petri-nets, and provides underlying formal static and dynamic semantics that are verified by automated reasoning tools. This paper first presents simplified MDE implementations of Petri-nets applying Java, QVT, Kermeta and fUML that we experimented in order to debug a safety-critical system and summarises the lessons learned from this study. Then, it provides formal alternatives, based on the B method and process algebra, which are well-established techniques allowing interactive animation on the one hand and reasoning about the behaviour correctness, on the other hand.},
	author = {Akram Idani},
	doi = {10.1007/s11334-021-00408-4},
	journal = {Innovations in Systems and Software Engineering},
	keywords = {DSL, Formal methods, B Specification, Animation, Proofs},
	month = {dec},
	number = 4,
	page = {543–566},
	publisher = {Springer},
	title = {Formal model-driven executable DSLs},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s11334-021-00408-4},
	volume = 18,
	year = 2022
}

@article{10.1134/S0361768824700865,
	abstract = {Abstract Geometric algebra is currently considered as a universal mathematical apparatus of computer graphics. Active research, both academic and applied, is being conducted in this area. Due to the applied nature of the research, many results are immediately implemented in the form of computer program code and libraries. One of such libraries is Ganja.js The aim of this paper is to review some capabilities of Ganja.js using the example of projective geometric algebra 
$${{\mathcal{C}}_{{2,0,1}}}(\mathbb{R})$$
 in its dual version. The paper uses the apparatus of linear algebra, elements of projective geometry, and geometric algebra (Clifford and Grassmann algebras). The software tools used are those of JavaScript. Ganja.js implements a mathematical syntax that allows you to define various Clifford algebras, manipulate their elements using algebraic operations, and visualize algebra elements as geometric objects. The created visualizations can be interactive and animated. Even though JavaScript is a completely unusual language for academic mathematical research, Ganja.js can be a useful tool for computation, visualization, and research in geometric algebra.},
	author = {M. N. Gevorkyan and T. R. Velieva and A. V. Korol’kova and D. S. Kulyabov and L. A. Sevast’yanov},
	doi = {10.1134/S0361768824700865},
	journal = {Programming and Computer Software},
	month = {apr},
	number = 2,
	page = {67–82},
	publisher = {Springer},
	title = {Projective Geometric Algebra in Plane and Its Implementation in the Library Ganja.js},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1134/S0361768824700865},
	volume = 51,
	year = 2025
}


@inproceedings{10.1007/978-3-031-66456-4_13,
	abstract = {The aim of this work is to translate railML 3 files to the formal B-method to enable formal verification and validation. railML is an XML-based format designed to facilitate the exchange of information about railway systems. Our approach allows syntactic and semantic validation against predefined and custom rules, using ProB and its integrated B-Rules DSL. In addition, a B-model can be generated to animate the dynamic behaviour of the specification, which can also be used for simulations and statistical tests using SimB . A technique for creating visualisations of the topology using Graphviz is presented. Finally, real-life railML case studies show that the implemented validation process can be effectively applied to complex models and that errors in these models can be successfully detected.},
	author = {Jan Gruteser and Michael Leuschel},
	booktitle = {Engineering of Complex Computer Systems},
	doi = {10.1007/978-3-031-66456-4_13},
	month = {jan},
	publisher = {Springer},
	title = {Validation of railML Using ProB},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-66456-4_13},
	year = 2025
}

@inproceedings{10.1007/978-3-031-85356-2_10,
	abstract = {The design and analysis of security in distributed computing systems raises numerous questions on the tools available for modeling and verification. Particularly, it is difficult to ensure the correctness when using different validation processes in software architecture design. Assuring cross-platform validation manually is labor intensive, expertise dependent, and error prone. This paper proposes an approach for the design and analysis of secure software architecture in the context of a component-port-connector architecture model and message passing communication. We use the Event-B formal method to create the software architecture model and security in successive steps using the refinement process. We also use proof obligations to verify the security of the successive software architecture models. Furthermore, we use the ProB model-checker and animator for the model validation.},
	author = {Loïc Thierry and Brahim Hamid and Jason Jaskolka},
	booktitle = {Verification and Evaluation of Computer and Communication Systems},
	doi = {10.1007/978-3-031-85356-2_10},
	keywords = {formal methods, model-driven engineering, component-based software architecture, security objectives, Event-B, ProB},
	month = {jan},
	publisher = {Springer},
	title = {A Formal Approach for Verifying and Validating Security Objectives in Software Architecture},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-85356-2_10},
	year = 2025
}


@inproceedings{10.1007/978-981-96-1621-3_13,
	abstract = {Verifying hybrid system designs is complex due to the integration of discrete and continuous features, requiring formal verification, simulation, and testing. This paper presents a strategy for generating Simulink models from verified hybridised Event-B models, which use a correct-by-construction approach to progressively build both types of behaviours. A key challenge in simulating these models is synchronising the discrete and continuous elements. Our objective is to translate hybridised Event-B models into Simulink, with Stateflow representing the discrete components and MATLAB function blocks for the continuous ones. We illustrate this process through a water tank case study, demonstrating formal modelling, verification, and subsequent simulation of the generated Simulink model.},
	author = {Neeraj Kumar Singh and Guillaume Dupont and Yamine Aït Ameur and Marc Pantel},
	booktitle = {Software Fault Prevention, Verification, and Validation},
	doi = {10.1007/978-981-96-1621-3_13},
	keywords = {Hybrid systems, Proof-based verification, Animation and Simulation, Event-B, Simulink},
	month = {jan},
	publisher = {Springer},
	title = {Generating Simulink Models from Hybridised Event-B Models},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-981-96-1621-3_13},
	year = 2025
}

@article{10.1007/s12369-025-01254-1,
	abstract = {Robotic technologies have not only been used in factories, but increasingly in various environments in people’s daily lives. Robots are used as assistive devices and through interaction with these devices it is possible to expand the physical and cognitive capabilities of humans. A new class of robots, Socially Assistive Robots (SARs), arises from the intersection of two other classes, assistive robots, which provide assistance, usually in healthcare settings, and interactive social robots, that communicate with the user. This work proposes an XML-based domain specific language (DSL) to facilitate the specification of interactive sessions for SARs. The proposed language is called EvaML and was designed for an open-source robotics platform. Although firstly implemented and used with EVA, EvaML can also be used with other SARs with similar communication affordances. To evaluate the EvaML language, an experiment was conducted with 12 software developers. Participants assessed EvaML with regards to clarity, effectiveness, perceived ease of use and usability according to 9 cognitive dimensions of the CDN framework (Cognitive Dimensions of Notations). EvaML was also successfully used by another group of 12 high school students and teachers in a series of activities where they designed and implemented interactive educational applications for EVA. Results indicate that EvaML is perceived as easy to use and usable, making it an adequate tool to enact interaction designs for a SAR platform considering different user profiles and levels of knowledge.},
	author = {Marcelo Marques da Rocha and Jesus Favela and Débora C. Muchaluat-Saade},
	doi = {10.1007/s12369-025-01254-1},
	journal = {International Journal of Social Robotics},
	keywords = {Domain specific languages, EvaML, Cognitive dimensions, Socially assistive robots},
	month = {may},
	page = {1–29},
	publisher = {Springer},
	title = {Design and Evaluation of an XML-Based Language for Programming Socially Assistive Robots},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s12369-025-01254-1},
	year = 2025
}

@inproceedings{10.1007/978-3-031-63790-2_5,
	abstract = {Petri-nets and their variants (Place/Transition nets, High-Level Petri Nets, etc.) are widely used in the development of safety critical-systems. Their success is related to three major aspects: a formal semantics, a graphical syntax and the availability of verification tools. In our previous work we presented a new vision for the semantic definition of Petri-nets applying a Formal Model-Driven Engineering (FMDE) built on the B method. The approach is powered by Meeduse , a language workbench that we developed in order to formally instrument executable Domain-Specific Languages (xDSLs) by applying a deep embedding technique and the B method. However, because of the abstract nature of the underlying formal models, our deep embedding is suitable for the validation and verification activities at the design stage but not sufficient to generate code for target platforms. This paper advances our previous work with a shallow embedding technique taking benefit of the B method tools in order to safely synthesize executable Petri-net controllers that can be embedded in target platforms.},
	author = {Akram Idani},
	booktitle = {Rigorous State-Based Methods},
	doi = {10.1007/978-3-031-63790-2_5},
	keywords = {B Method, Petri-nets, Verification, Formal MDE},
	month = {jan},
	publisher = {Springer},
	title = {Transpilation of Petri-nets into B},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-63790-2_5},
	year = 2024
}

@inproceedings{10.1007/978-3-031-59235-5_6,
	abstract = {Domain-Specific Languages allow domain experts to specify their knowledge in such a way that software can be generated based on those specifications. In the context of a project using a humanoid robot Pepper as coach in therapies of post stroke patients we developed the language TaskDSL4Pepper and StateDSL4Pepper. They allow therapists to specify the behavior of a robot based on the two concepts of task models and hierarchical state machines. The paper discusses both languages that support commands like say ?< text > , show ?< image > , play ?< video > and raiseArms . First feedback from therapists in comparing both languages is discussed.},
	author = {Peter Forbrig and Alexandru Umlauft and Mathias Kühn and Anke Dittmar},
	booktitle = {Engineering Interactive Computer Systems. EICS 2023 International Workshops and Doctoral Consortium},
	doi = {10.1007/978-3-031-59235-5_6},
	keywords = {Domain-Specific Languages, Humanoid Robot Pepper, Behavior},
	month = {jan},
	publisher = {Springer},
	title = {Two Concepts of Domain-Specific Languages for Therapists to Control a Humanoid Robot},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-59235-5_6},
	year = 2024
}

@article{10.1007/s10270-022-01025-w,
	abstract = {Executable Domain-Specific Languages (xDSLs) allow the definition and the execution of behavioral models. Some behavioral models are reactive, meaning that during their execution, they accept external events and react by exposing events to the external environment. Since complex interaction may occur between the reactive model and the external environment, they should be tested as early as possible to ensure the correctness of their behavior. In this paper, we propose a set of generic testing facilities for reactive xDSLs using the standardized Test Description Language (TDL). Given a reactive xDSL, we generate a TDL library enabling the domain experts to write and run event-driven TDL test cases for conforming reactive models. To further support the domain expert, the approach integrates interactive debugging to help in localizing defects, and mutation analysis to measure the quality of test cases. We evaluate the level of genericity of the approach by successfully writing, executing, and analyzing 247 event-driven TDL test cases for 70 models conforming to two different reactive xDSLs.},
	author = {Faezeh Khorram and Erwan Bousse and Jean-Marie Mottu and Gerson Sunyé},
	doi = {10.1007/s10270-022-01025-w},
	journal = {Software and Systems Modeling},
	keywords = {Reactive executable DSL, Testing, Test description language, Debugging, Mutation analysis},
	month = {jun},
	number = 3,
	page = {819–845},
	publisher = {Springer},
	title = {Advanced testing and debugging support for reactive executable DSLs},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01025-w},
	volume = 22,
	year = 2023
}


@inproceedings{10.1007/978-3-031-21595-7_9,
	abstract = {Safety-critical systems are increasingly model-based, since model-based system engineering (MBSE) paradigm reduces the time-to-market and allows evolving systems at different abstraction levels. Different languages have been proposed recently enabling to facilitate the modeling process and shorten the development life-cycle. However, these languages may be used at one or many modeling steps regarding the semantics of their artefacts. Capella language is one of these languages that gained popularity recently. It is dedicated to system engineering and its use may very beneficial for safety-critical system. However, designing with Capella is considered as semi-formal. Thus, the approach presented in this paper stands for systematic formal verification of Capella’s behavioral models using Event-B method in a transparent way. Our proposal translates Capella models into Event-B specifications using automatic model-to-model transformations dedicated to Capella designers. The verification of correctness of the transformed models is provided by the ProB model-checker. An automatic lighting system is treated as a case study to validate of our contribution.},
	author = {Khaoula Bouba and Abderrahim Ait Wakrime and Yassine Ouhammou and Redouane Benaini},
	booktitle = {Model and Data Engineering},
	doi = {10.1007/978-3-031-21595-7_9},
	keywords = {Model-based system engineering, Formal methods, Capella/arcadia, Event-b, Meta-model, Operational analysis},
	month = {jan},
	publisher = {Springer},
	title = {Towards the Strengthening of Capella Modeling Semantics by Integrating Event-B: A Rigorous Model-Based Approach for Safety-Critical Systems},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-21595-7_9},
	year = 2023
}


@inproceedings{10.1007/978-3-031-45438-7_28,
	abstract = {The Internet of Things (IoT) has become one of the fundamental pillars of the digital transformation of society, with favorable impacts on people’s quality of life. Furthermore, IoT systems generate large volumes of data at very high speeds, which come from diverse sources (heterogeneous sensors), requiring the permanent adaptation of the content and the way of presenting the information to the user; hence, a low-level implementation approach becomes unproductive. In this context, Model-Driven Engineering (MDE) has proven to be an appropriate software development approach to cope with the complexity and evolution of IoT systems. However, there are few proposals for Domain-Specific Languages (DSLs) aimed at building dashboards that synthesize the metrics and fundamental monitoring data of an IoT system. Therefore, this paper proposes a DSL and a model-based transformation engine to design and automatically implement IoT dashboard visualization web applications that combine pages, panels, charts, grids, data filters, hyperlinks, and labels with warnings and prescriptive recommendations. In addition, the proposed solution abstracts implementation details from heterogeneous data sources (physical and virtual sensors), making them transparent to domain experts. The empirical evaluation of the solution through a quasi-experiment based on the Method Evaluation Model (MEM) showed that the participants perceived the solution as useful and easy to use, so they would be willing to use it in the future.},
	author = {Lenin Erazo-Garzon and Kevin Quinde and Alexandra Bermeo and Priscila Cedillo},
	booktitle = {Information and Communication Technologies},
	doi = {10.1007/978-3-031-45438-7_28},
	keywords = {Dashboard, Domain-Specific Language (DSL), Internet of Things (IoT), Model-Driven Engineering (MDE), Transformation Engine, User Interface (UI)},
	month = {jan},
	publisher = {Springer},
	title = {A Domain-Specific Language and Model-Based Engine for Implementing IoT Dashboard Web Applications},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-45438-7_28},
	year = 2023
}

@inproceedings{10.1007/978-3-031-38821-7_7,
	abstract = {Decomposition allows for managing complexity. We show that executable models of behaviour are significantly more decomposable when using a time-triggered semantics than an event-driven semantics. Therefore, we adopt logic-labelled finite machines LLFSMs and show that deterministic static schedules are derived to guarantee value-domain properties and time-domain properties. We illustrate that such a decomposition goes a long way in avoiding the combinatorial space explosion that occurs when attempting to formally verify executable behaviour models. We argue for parametrised machines to foster decomposability and analyse what aspects jeopardise taming the size of Kripke structures for formal verification. We provide three case studies to show that we can transform the models into small, timed Kripke structures and that components can be verified separately by the nuXmv model checker to achieve formal system verification.},
	author = {Callum McColl and Vladimir Estivill-Castro and Morgan McColl and René Hexel},
	booktitle = {Model-Driven Engineering and Software Development},
	doi = {10.1007/978-3-031-38821-7_7},
	keywords = {Systems engineering, Decomposition, Real-time Systems, Timing properties, Formal Verification},
	month = {jan},
	publisher = {Springer},
	title = {Decomposable and Executable Models for Verification of Real-Time Systems},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-38821-7_7},
	year = 2023
}


@article{10.1007/s10270-022-01009-w,
	abstract = {BPMN Sketch Miner is a modeling environment for generating visual business process models starting from constrained natural language textual input. Its purpose is to support business process modelers who need to rapidly sketch visual BPMN models during interviews and design workshops, where participants should not only provide input but also give feedback on whether the sketched visual model represents accurately what has been described during the discussion. In this article, we present a detailed description of the BPMN Sketch Miner design decisions and list the different control flow patterns supported by the current version of its textual DSL. We also summarize the user study and survey results originally published in MODELS 2020 concerning the tool usability and learnability and present a new performance evaluation regarding the visual model generation pipeline under actual usage conditions. The goal is to determine whether it can support a rapid model editing cycle, with live synchronization between the textual description and the visual model. This study is based on a benchmark including a large number of models (1350 models) exported by users of the tool during the year 2020. The main results indicate that the performance is sufficient for a smooth live modeling user experience and that the end-to-end execution time of the text-to-model-to-visual pipeline grows linearly with the model size, up to the largest models (with 195 lines of textual description) found in the benchmark workload.},
	author = {Ana Ivanchikj and Souhaila Serbout and Cesare Pautasso},
	doi = {10.1007/s10270-022-01009-w},
	journal = {Software and Systems Modeling},
	keywords = {Business Process Model and Notation (BPMN), Process mining, Domain-specific languages, Performance evaluation},
	month = {oct},
	number = 5,
	page = {1877–1906},
	publisher = {Springer},
	title = {Live process modeling with the BPMN Sketch Miner},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01009-w},
	volume = 21,
	year = 2022
}


@article{10.1007/s11042-021-11316-x,
	abstract = {This paper presents an approach to the production of web-based interactive fiction, which is grounded in the requirements posed by an expert focus group, and which integrates a domain-specific language (DSL) for interactive fiction (HEXIFE) and an authoring tool for this DSL (IFDBMaker). HEXIFE is an extension of HMTL5 that includes markup specifically devoted to different aspects of interactive fiction, such as hyperlinking, choice points, personalization, stretchtext, annotations, conditional content, and gamification. This DSL, which can be easily extended with new interactive fiction behaviors, is supported by a runtime environment based on conventional web technologies (HTML5, CSS3, JavaScript, Web Components, PHP, and MySQL). IFDBMaker, in turn, piggybacks in a widely used web-based HTML editing framework (TinyMCE) to allow the creation of interactive HEXIFE fiction through a user-friendly approach. A postmortem evaluation shows how: (i) the approach makes the feasibility of supporting interactive fiction on conventional web technologies apparent; and (ii) the approach is a feasible one to actively involve writers in the final production of interactive fiction that are distributed and played through the web.},
	author = {Mercedes Gómez-Albarrán and Antonio Sarasa-Cabezuelo and José-Luis Sierra-Rodríguez and Bryan Temprado-Battad},
	doi = {10.1007/s11042-021-11316-x},
	journal = {Multimedia Tools and Applications},
	keywords = {Interactive fiction, Domain-specific language, Authoring tool, Web technologies, Digital edition, Digital humanities},
	month = {may},
	number = 11,
	page = {14705–14747},
	publisher = {Springer},
	title = {Authoring and playing interactive fiction with conventional web technologies},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s11042-021-11316-x},
	volume = 81,
	year = 2022
}


@inproceedings{10.1007/978-3-031-21488-2_11,
	abstract = {Many powerful metamodeling platforms exist, each with strengths, weaknesses, functionalities, programming language(s), and developer community. To exploit the mutual benefits of these platforms, it would be ideal to establish interoperability amongst them and the exchange of metamodels and models. This would enable language engineers to choose the metamodeling platform freely without risking a lock-in effect. Two well-documented and freely available metamodeling platforms are the Eclipse Modeling Framework (EMF) and Microsoft’s Modeling SDK for Visual Studio (MSDKVS). This paper proposes the first achievements toward establishing interoperability between EMF and MSDKVS on an abstract syntax level and a graphical concrete syntax level. To develop such interoperability, we i ) comprehensively analyze the two platforms, ii ) present a conceptual mapping between them, and iii ) eventually implement a bidirectional transformation bridge. The transformed results’ validity, executability, and expressiveness are then quantitatively and qualitatively assessed by transforming a collection of publicly available metamodels.},
	author = {Florian Cesal and Dominik Bork},
	booktitle = {The Practice of Enterprise Modeling},
	doi = {10.1007/978-3-031-21488-2_11},
	keywords = {Metamodeling, Interoperability, EMF, Sirius, DSL, MSDKVS},
	month = {jan},
	publisher = {Springer},
	title = {Establishing Interoperability Between the EMF and the MSDKVS Metamodeling Platforms},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-21488-2_11},
	year = 2022
}


@article{10.1007/s12369-021-00768-8,
	abstract = {We present the Dynamic Stack Decider  (DSD), a lightweight open-source control architecture. It combines different well-known approaches and is inspired by behavior trees as well as hierarchical state machines . The DSD allows to design and structure complex behavior of robots as well as software agents while providing easy maintainability. Challenges that often occur in robotics, i.e., a dynamic environment and situation uncertainty, remain well-manageable. Furthermore, it allows fast modifications of the control flow, while providing the state-fullness of a state machine. The approach allows developing software using a simple Domain Specific Language (DSL) which defines the control flow and two types of elements that contain the programmed parts. The framework takes care of executing the demanded portions of the code and gives, due to its stack-like internal representation, the ability to verify preconditions while maintaining a clear structure. The presented software was used in different robotic scenarios and showed great performance in terms of flexibility and structuredness.},
	author = {Martin Poppinga and Marc Bestmann},
	doi = {10.1007/s12369-021-00768-8},
	journal = {International Journal of Social Robotics},
	keywords = {Control architecture, Framework, Behavior, Robots, Agents},
	month = {jan},
	number = 1,
	page = {73–83},
	publisher = {Springer},
	title = {DSD - Dynamic Stack Decider},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s12369-021-00768-8},
	volume = 14,
	year = 2022
}

@inproceedings{10.1007/978-3-031-89471-8_31,
	abstract = {Ensuring reliable performance in tasks with high variability is an increasingly important task in the engineering process of robotics applications. This paper introduces an extended toolchain leveraging Behaviour-Driven Development to specify acceptance criteria and high-quality simulations to execute acceptance tests. We demonstrate the effectiveness of the testing approach in a dynamic sorting task with objects picked from a moving conveyor using a Franka Panda robot system. The contributions include an extended domain-specific language for specifying acceptance criteria and an implementation for automated testing of sorting scenarios using NVIDIA IsaacSim. We conclude with a discussion on the current state and future work on acceptance testing for robotics.},
	author = {Bastian Hunecke and Minh Nguyen and Nico Hochgeschwender and Sebastian Wrede},
	booktitle = {European Robotics Forum 2025},
	doi = {10.1007/978-3-031-89471-8_31},
	keywords = {Robot system and software engineering, Robot manipulation, Acceptance testing},
	month = {jan},
	publisher = {Springer},
	title = {Specification and Execution of Robotic Acceptance Tests for Object Sorting},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-89471-8_31},
	year = 2025
}


@article{10.1016/j.ece.2025.05.003,
	author = {Gutiérrez-Guerra R.},
	doi = {10.1016/j.ece.2025.05.003},
	journal = {Education for Chemical Engineers},
	month = {jul},
	page = {51-68},
	title = {Development and implementation of an APP to simulate centrifugal compressors},
	url = {https://api.elsevier.com/content/abstract/scopus_id/105005090299},
	volume = 52,
	year = 2025
}


@article{10.1061/JCEMD4.COENG-15495,
	author = {Shao Y.},
	doi = {10.1061/JCEMD4.COENG-15495},
	journal = {Journal of Construction Engineering and Management},
	month = {feb},
	number = 2,
	title = {Revelation and Enhancement for Pedestrian Evacuation at Metro Station: Metamodeling-Based Simulation Optimization Approach},
	url = {https://api.elsevier.com/content/abstract/scopus_id/85211923123},
	volume = 151,
	year = 2025
}

@inproceedings{10.1007/978-3-031-19756-7_8,
	abstract = {Regarding documentation as anything that supports understanding , we present two test-first scenarios of executable documentation that involve and support different roles during program development through concrete data visualizations. The first is a teaching scenario. Within classical programming, different stages of executable documentation provide faceted layers of self-learning and user-centric diagnostics. Students and teachers benefit from auto-didactic exploration, appropriate diagram syntheses for runtime visualization, and automated test case generation. The latter can be created using reference implementations provided by the teacher but can also be used to foster the dialog between students and tutors. The second scenario introduces a new approach to WYSIWYG GUI editing that is able to render the runtime GUI appearance in real-time within the editor. Using scenario-based test cases, users can seamlessly experience, inspect, and test the GUI while they are editing. The paper discusses the impact of the provided tangible experiences and their role in modern IDEs.},
	author = {Steven Smyth and Jette Petzold and Jonas Schürmann and Florian Karbus and Tiziana Margaria and Reinhard Hanxleden and Bernhard Steffen},
	booktitle = {Leveraging Applications of Formal Methods, Verification and Validation. Software Engineering},
	doi = {10.1007/978-3-031-19756-7_8},
	keywords = {Documentation, Teaching, Test-driven development, Automatic layout, Verification, Web technologies},
	month = {jan},
	publisher = {Springer},
	title = {Executable Documentation: Test-First in Action},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-19756-7_8},
	year = 2022
}

@inproceedings{10.1007/978-981-96-2684-7_19,
	abstract = {There are two challenges in the GUI code generation tasks: insufficient image feature extraction capability and low accuracy of code generation. Existing methods can handle simple GUI datasets well but have difficulty with complex GUI datasets. We propose a method for automatic code generation from GUI screenshots with vision-language models. Our method uses a multimodal information fusion module to fuse feature information from images and code efficiently. To improve the accuracy and feature extraction capability of GUI code generation, we use a combination of automated metrics to evaluate the performance of our method. The multiple experimental results demonstrate that our method achieves better performance among existing methods on both existing public and newly constructed datasets in the GUI code generation field. In particular, the BLUE4 score has been improved by 27},
	author = {Jingbin Liang and Jing Liang and Shuang Li},
	booktitle = {Computer Animation and Social Agents},
	doi = {10.1007/978-981-96-2684-7_19},
	keywords = {GUI, code generation, vision-language models, attention mechanism, multimodal fusion},
	month = {jan},
	publisher = {Springer},
	title = {Automatic Code Generation from GUI Screenshots with Vision-Language Models},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-981-96-2684-7_19},
	year = 2025
}


@article{10.1007/s40860-021-00164-z,
	abstract = {With spatial user interaction, system functions are triggered in response to spatial events. These latter are built from spatial attributes of the tracked entities or spatial relations between them. We call these entities spatial interactors (spins). Spins can be user bodies or tangible objects manipulated by users. Spatial interaction offers intuitive interactions between users and their environment, especially within ambient smart environments. Such paradigm of user interaction finds its use in daily life where interconnected objects are in constant interaction. Many spatial applications exist but they are generally constructed based on ad hoc developments. In fact, there is a lack of generic approaches capable of supporting the process of building spatial applications, from the design phase to the deployment one. In this context, following a model-driven engineering (MDE) approach, we propose a spatial interaction modeling language called SUIL (spatial user interaction language). We propose likewise a framework called SUIC (spatial user interface creator) for modeling and code generating of spatial interfaces. To prove the feasibility of our approach, we present a case study that we carried out through our framework.},
	author = {Khadidja Chaoui and Sabrina Bouzidi-Hassini and Yacine Bellik},
	doi = {10.1007/s40860-021-00164-z},
	journal = {Journal of Reliable Intelligent Environments},
	keywords = {Ambient environments, Interaction design, Spatial user interaction, Model-driven engineering (MDE), Domain-specific language (DSL)},
	month = {jun},
	number = 2,
	page = {161–181},
	publisher = {Springer},
	title = {SUIL: a modeling language for spatial user interaction},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s40860-021-00164-z},
	volume = 9,
	year = 2023
}


@inproceedings{10.1007/978-3-031-25182-5_19,
	abstract = {Model-based systems engineering (MBSE) combines the rigor of systems engineering with formal models to support communication in multidisciplinary engineering. With industrial adoption of MBSE, the maturity of modeling environments supporting MBSE increased. Still, efficient means to integrate computational design methods in MBSE are missing. Here, we present a method that enables systems engineers to directly integrate computational methods for solving design tasks. The method relies on established semantics of the systems modeling language (SysML) and therefore can be directly integrated with existing system models so to avoid redundant knowledge formalizations for computational methods. Next, model transformations are applied to generate the mathematical model based on the relevant parts of the system model. These temporary models are used to solve the design task and generate output that is fed back to the system model. Therefore, the proposed method contributes by relying on a single and comprehensible knowledge formalization understandable to engineers. Further, it enables systems engineers to formalize design tasks for automated reasoning themselves by bundling the complexity of the mathematical modeling within the model transformations. An industrial case for designing sealing elements for piping is used to illustrate the potential of the proposed approach. Future work needs to further elaborate on automated selection of appropriate mathematical methods as well as computational support for the identification of opportunities for integration of computational design methods readily while developing a system model.},
	author = {Eugen Rigger and Simon Rädler and Tino Stankovic},
	booktitle = {Product Lifecycle Management. PLM in Transition Times: The Place of Humans and Transformative Technologies},
	doi = {10.1007/978-3-031-25182-5_19},
	keywords = {Model-based systems engineering, SysML, Computational design method, Design automation},
	month = {jan},
	publisher = {Springer},
	title = {Integrating Computational Design Support in Model-Based Systems Engineering Using Model Transformations},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-25182-5_19},
	year = 2023
}


@inproceedings{10.1007/978-3-031-15116-3_2,
	abstract = {The ever increasing complexity of modern software systems requires engineers to constantly raise the level of abstraction at which they operate to suppress the excessive complex details of real systems and develop efficient architectures. Model Driven Engineering has emerged as a paradigm that enables not only abstraction but also automation. UML, an industry de-facto standard for modelling software systems, has established itself as a diagram-based modelling language. However, focusing on only one specific notation limits human communication and the pool of available engineering tools. The results of our prior experiments support this claim and promote the seamless use of multiple notations to develop and manipulate models. In this paper we detail our efforts on the provision of a fully blended (i.e., graphical and textual) modelling environment for UML-RT state-machines in an industrial context. We report on the definition of a textual syntax and advanced textual editing for UML-RT state-machines as well as the provision of synchronization mechanisms between graphical and textual editors.},
	author = {Malvina Latifaj and Federico Ciccozzi and Muhammad Waseem Anwar and Mattias Mohlin},
	booktitle = {Software Architecture},
	doi = {10.1007/978-3-031-15116-3_2},
	keywords = {UML-RT, HCL RTist, Xtext, QVTo, Model transformation, Model synchronization, Blended modelling},
	month = {jan},
	publisher = {Springer},
	title = {Blended Graphical and Textual Modelling of UML-RT State-Machines: An Industrial Experience},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-15116-3_2},
	year = 2022
}

@inproceedings{10.1007/978-3-031-06653-5_7,
	abstract = {This paper describes the IOPT-Tools cloud-based tool-chain, offering a complete set of tools supporting design automation for embedded controller’s development, benefiting from adopting a model-driven development attitude. The tools are freely available online at http://gres.uninova.pt/IOPT-Tools/ . The tool-chain relies on IOPT nets (Input-Output Place-Transition nets) to describe the controller behavior, allowing an explicit representation of constraints on input and output signals and events, which is necessary for the development of controllers. The IOPT-Tools tool-chain includes tools for interactive graphical IOPT nets models editing, simulation and test (token-player, timing diagram, remote debugging), as well as a state-space generator, state-space visualization, and a query system for properties verification. The tool-chain also supports the automatic generation of execution code to be directly deployed in the controllers’ implementation platforms, such as FPGA boards, as well as Arduino, Raspberry, and other Linux-based boards. Most notably, it is possible to obtain C code and VHDL code to be directly deployed into the referred boards without writing/changing a line in the generated code. The tool-chain uses the PNML format for storing the models and can import PNML models generated by other frameworks, automatically generating, if necessary, an associated graphical representation. After, it is possible to add input and output signals and events to create controller models. IOPT-Tools also supports net operations, namely net addition, allowing composition of sub-models, and net splitting, which in conjunction with the use of clock domains and dedicated communication channels support the development of distributed controllers.},
	author = {Fernando Pereira and Filipe Moutinho and Anikó Costa and João-Paulo Barros and Rogério Campos-Rebelo and Luis Gomes},
	booktitle = {Application and Theory of Petri Nets and Concurrency},
	doi = {10.1007/978-3-031-06653-5_7},
	keywords = {Embedded controllers, Design Automation, Code Generation, Petri nets},
	month = {jan},
	publisher = {Springer},
	title = {IOPT-Tools – From Executable Models to Automatic Code Generation for Embedded Controllers Development},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-06653-5_7},
	year = 2022
}


@article{10.1007/s10270-022-01073-2,
	abstract = {Recent results in language engineering simplify the development of tool-supported executable domain-specific modeling languages (xDSMLs), including editing (e.g., completion and error checking) and execution analysis tools (e.g., debugging, monitoring and live modeling). However, such frameworks are currently limited to sequential execution traces and cannot handle execution traces resulting from an execution semantics with a concurrency model supporting parallelism or interleaving. This prevents the development of concurrency analysis tools, like debuggers supporting the exploration of model executions resulting from different interleavings. In this paper, we present a generic framework to integrate execution semantics with either implicit or explicit concurrency models, to explore the possible execution traces of conforming models, and to define strategies for helping in the exploration of the possible executions. This framework is complemented with a protocol to interact with the resulting executions and hence to build advanced concurrency analysis tools. The approach has been implemented within the GEMOC Studio. We demonstrate how to integrate two representative concurrent meta-programming approaches (MoCCML/Java and Henshin), which use different paradigms and underlying foundations to define an xDSML’s concurrency model. We also demonstrate the ability to define an advanced concurrent omniscient debugger with the proposed protocol. The paper, thus, contributes key abstractions and an associated protocol for integrating concurrent meta-programming approaches in a language workbench, and dynamically exploring the possible executions of a model in the modeling workbench.},
	author = {Steffen Zschaler and Erwan Bousse and Julien Deantoni and Benoit Combemale},
	doi = {10.1007/s10270-022-01073-2},
	journal = {Software and Systems Modeling},
	keywords = {Language engineering, Model execution, Model concurrency, Simulation, Concurrent analyses/debugging},
	month = {aug},
	number = 4,
	page = {1319–1340},
	publisher = {Springer},
	title = {A generic framework for representing and analyzing model concurrency},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01073-2},
	volume = 22,
	year = 2023
}

@article{10.1016/j.cola.2025.101325,
	author = {Tezel B.T.},
	doi = {10.1016/j.cola.2025.101325},
	journal = {Journal of Computer Languages},
	month = {jun},
	title = {Debugging in the Domain-Specific Modeling Languages for multi-agent systems},
	url = {https://api.elsevier.com/content/abstract/scopus_id/85218457775},
	volume = 83,
	year = 2025
}


@inproceedings{10.1007/978-3-031-66339-0_7,
	abstract = {Models are central to the study of complex systems, both human-made and natural. They assist in making important decisions with regard to design and development of systems, and in planning a variety of actions in areas of everyday life, economy, the environment and more; and models are, of course, an essential element of scientific research. We examine several inherent difficult-to-implement requirements common to many models of complex systems that are part of, or work in, the real world. In this paper we describe the challenges associated with the following aspects of modeling complex systems: (i) Complex real-world systems are exposed to an unbounded number of external and internal inputs and stimuli, and in reacting to such triggers, the system engages in a two-way interaction with its environment and with each of the particular sources of these inputs. (ii) New patterns, new relationships and, indeed, new entities, continually emerge, and the system manifests emergent reaction to these group effects. (iii) Either by human design, or by underlying laws of nature, complex cohesive system behavior often manifests the composite effects of separate, parallel, self standing requirements or natural phenomena that are integrated subject to some universal composition principles. (iv) Events and processes in such a system occur, or exist, on distinct time scales. We describe each of these challenges, propose concrete guidelines in modeling that can help cope with them, and outline directions for relevant features in modeling tools. An important element in dealing with these obstacles is unmodeling —explicitly documenting and specifying model elements that are excluded from simulations and model transformation for a variety of reasons. Such unmodeling enhances model quality, supports incremental enhancement, and facilitates evaluation of the model. This paper is one of the outcomes of a combined view of our research on modeling languages and our research on biological evolution. Bringing these kinds of difficulties and the ways to tackle them to the forefront of modeling research can contribute to the quality and usefulness of future models and systems.},
	author = {Assaf Marron and Irun R. Cohen and Guy Frankel and David Harel and Smadar Szekely},
	booktitle = {Model-Driven Engineering and Software Development},
	doi = {10.1007/978-3-031-66339-0_7},
	keywords = {Modeling, Simulation, Emergent entities, Rule-based specifications, Incremental development, Evolution, Time scale},
	month = {jan},
	publisher = {Springer},
	title = {Challenges in Modeling and Unmodeling Complex Reactive Systems: Interaction Networks, Reaction to Emergent Effects, Reactive Rule Composition, and Multiple Time Scales},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-66339-0_7},
	year = 2024
}

@article{10.3390/app15137062,
	author = {Chen S.},
	doi = {10.3390/app15137062},
	journal = {Applied Sciences Switzerland},
	month = {jul},
	number = 13,
	title = {Vulnerability Assessment Framework for Physical Protection Systems Integrating Complex Networks and Fuzzy Petri Nets},
	url = {https://api.elsevier.com/content/abstract/scopus_id/105010339970},
	volume = 15,
	year = 2025
}

@inproceedings{10.1007/978-3-031-61433-0_1,
	abstract = {Nowadays Discrete Event Systems (DESs) require complex and large models, for which distributed simulation engines become, in practice, the tools used to understand and analyze their behavior. The feasibility and efficiency of a distributed simulation of these large-scale models is strongly dependent of the information that can be obtained from the models, previously to the simulation process itself. This information can give assistance to the generation of an initial partition of the model, allowing a well balanced workload among the individual simulation engines deployed, or in the generation of the predicates to be evaluated in order to determine the enabling of transitions; or the computation of look-ahead information in conservative strategies of distributed simulation. Petri nets allow to obtain information from the structure that can be used to advance conclusions or properties about the course of a simulation. This information can be usefull either independently of the considered initial marking, or parameterised by its initial choice. This structural information can be obtained in modelling phase, completed in simulation time and re-elaborated from the simulation results, and therefore associated to the model or modules of the model in such a way that can be harnessed in further simulations where these nets will be used. Last but no least, the maintenance of the structure of the Petri net during the simulation (in an interpreted simulation instead of a compiled one) allows to make load balancing during the simulation or to federate with legacy simulators, in an easier way than using other kind of specification models or simulation schemes.},
	author = {José-Manuel Colom},
	booktitle = {Application and Theory of Petri Nets and Concurrency},
	doi = {10.1007/978-3-031-61433-0_1},
	keywords = {Petri Nets, Structural Analysis, Distributed Simulation, Discrete Event Systems},
	month = {jan},
	publisher = {Springer},
	title = {Harnessing Structure Theory of Petri Nets in Discrete Event System Simulation},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-61433-0_1},
	year = 2024
}

@inproceedings{10.1007/978-3-031-51452-4_9,
	abstract = {In this work we explore the potential of using a Petri Nets inspired graphic interface supporting a character action modeling mechanic to develop computational thinking skills in a game-based learning environment. We conceived a proof-of-concept paper prototype as a probe to perform gameplay rehearsals and distill insights on how young players would appropriate it. A qualitative research approach was used to study gameplay sessions and semi-structured interviews, coding player actions and dialogue. We were able to gain insights on how the design of the game components and its mechanics mimicking Petri Nets provided an accessible way for players to perform the game activities by modeling behaviors of game characters. The integration of an interface design for action modeling inspired by Petri Nets and the use of symbols for encoding conditions, actions and outcomes, allowed players to model complex sequences of behavior, recognize patterns, decompose in-game activities, and work with abstractions such as conditions, consequences and steps. This enabled players’ articulation of cause-and-effect relationships, leading to the consolidation of computational thinking skills. This work provides insights for exploring similar design patterns in gameplay to enhance Computational Thinking.},
	author = {Valéria Moreira Pinto and Mariana Seiça and Licínio Roque},
	booktitle = {Videogame Sciences and Arts},
	doi = {10.1007/978-3-031-51452-4_9},
	keywords = {Player Modeled Actions, Computational thinking, Game Design, Petri Nets, STEAM},
	month = {jan},
	publisher = {Springer},
	title = {How Players Develop Computational Thinking While Modeling Character Behaviors in Gameplay},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-51452-4_9},
	year = 2024
}

@inproceedings{10.1007/978-981-97-9255-9_32,
	abstract = {While there? much excitement about machine learning (ML), the ML models driving our daily interactions are often blackboxed and inaccessible to the broader audience. A major problem is the lack of concrete visual representations that any user can manipulate to understand their results. We aim to provide an accessible ML representation by coupling the data and model with a visual-rule based interface. We present Learner? Permit, an interactive programming game where the player? objective is to teach a car to drive itself. In Learner? Permit, we aim to support the entire ML workflow, including data collection, training, testing and debugging. By combining the principles of visual rule programming and interpretable AI, we are able to build a novel game that makes ML accessible for all audiences.},
	author = {Joyce Yuan and Henry Lieberman and David Canfield Smith and Yida Xin},
	booktitle = {Artificial Intelligence in Education Technologies: New Development and Innovative Practices},
	doi = {10.1007/978-981-97-9255-9_32},
	keywords = {AI for education, accessible / interpretable AI, machine learning, game design for education, visual rules, debugging},
	month = {jan},
	publisher = {Springer},
	title = {Learner? Permit: Accessible Artificial Intelligence Through anEducational Game},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-981-97-9255-9_32},
	year = 2025
}

@article{10.1007/s10270-025-01311-3,
	abstract = {The management of modern communication networks requires sophisticated, specialized tooling that, akin to an operating system, provides an appropriately abstracted view of the network and its resources together with a broad and extensible range of functionality to observe, analyze, and change different aspects of the network such as software-defined networking. This research explores the process of extending network management platforms, focusing specifically on a management platform in use at TELUS, a leading Canadian communication and IT company. The TELUS Intelligent Network Automation and Analytics (TINAA) is a model-driven control and management ecosystem. TINAA uses MDE techniques and YANG, a data modeling language widely used in the networking domain, to facilitate the implementation of new network functions. More specifically, to add a network function to TINAA, the following process is used: (1) The function is described using YANG. (2) Skeleton code is generated from these models. (3) The skeleton code is modified and completed as appropriate by a developer. In particular, we demonstrate how YANG’s language extension mechanism, combined with code clone detection and removal, can capture essential information at the model level and generate cleaner, more readable skeleton code, significantly simplifying the manual code completion process. We evaluate our techniques using the L3VPN Network Model (L3NM), a widely adopted model for managing and configuring Layer 3 VPN services. We identify general lessons learned of interest to both the networking and the MDE community.},
	author = {Hesham Elabd and Juergen Dingel and Tung Fai Lau and Ali Tizghadam},
	doi = {10.1007/s10270-025-01311-3},
	journal = {Software and Systems Modeling},
	keywords = {Model-based engineering, Model-driven network automation, NetOps, Project scaffolding, Network function virtualization, RESTful API specification, Software-defined networking (SDN), YANG, Business Process Modeling Notation (BPMN), Code clones, Refactoring},
	month = {aug},
	page = {1–28},
	publisher = {Springer},
	title = {Enhancing automated network function onboarding through language extension and code refactoring},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-025-01311-3},
	year = 2025
}

@article{10.1007/s10270-023-01093-6,
	abstract = {Intelligent virtual model assistance is a key challenge in cultivating model-driven engineering proliferation and growth. Such assistance will help improve the quality of software models, support education for students learning modeling, and lower the entry barriers to new modelers. We present SimIMA, an intelligent modeling assistant for Simulink, which is an extremely popular modeling language in both industry and academia. SimIMA provides modelers with two different forms of data-driven guidance using a knowledge base of configurable repositories and sources. The first form of guidance, SimGESTION, suggests to modelers single-step operations they can perform on their models as they edit them in their modeling environment. These suggestions are based on the machine learning technique of ensemble learning through association rule mining and frequency classification. The second form of guidance, SimXAMPLE, presents modelers with similar/related Simulink systems for modelers to either insert directly into their environments or to view for inspiration. SimXAMPLE accomplishes this through model clone detection. To validate SimIMA, we conduct experiments using an established, open, and curated large set of Simulink models coming from a variety of application domains. Our results show that both of SimIMA’s forms of guidance are inferring the appropriate model and element suggestions given SimIMA’s knowledge base and that SimIMA is both scalable and efficient. Through our evaluation, SimIMA demonstrates a prediction accuracy of 78.86},
	author = {Bhisma Adhikari and Eric J. Rapos and Matthew Stephan},
	doi = {10.1007/s10270-023-01093-6},
	journal = {Software and Systems Modeling},
	month = {feb},
	number = 1,
	page = {29–56},
	publisher = {Springer},
	title = {SimIMA: a virtual Simulink intelligent modeling assistant},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-023-01093-6},
	volume = 23,
	year = 2024
}


@article{10.1007/s10270-023-01104-6,
	abstract = {Software modeling has shown for many years that it brings many advantages at the cost of various efforts and constraints. A large corpus of literature has indeed grown up over the years, pointing out the problems related to the modeling abstraction process, the usability of tools, or the practical difficulty of using modeling languages. While these works identify problems, few of them focus on proposing directions to explore in order to fix them. To move toward a smoother and less constraining modeling experience and then increase the added value of modeling approaches, it is necessary to identify new paths to improve current tooling. In this paper, we explore one specific path by investigating how new software assistance features could support users performing modeling tasks that they perceive as complex. We used UML knowledge as a criterion for the selection of participants and built a questionnaire general to software modeling. We followed a user-centered research approach and collected the feedback from practitioners who use the modeling languages and the modeling tools on a regular basis in an industrial context. This article reports on a set of individual interview sessions with 16 modeling experts about how they perform modeling and how they imagine assistance in the context of their work. From the analysis of this qualitative study, we draw twelve observations on how to design software assistants for software modeling. These observations highlight research directions for both tool vendors and academics to explore, to identify and design new solutions to the friction points of the software modeling experience.},
	author = {Maxime Savary-Leblanc and Xavier Le Pallec and Sébastien Gérard},
	doi = {10.1007/s10270-023-01104-6},
	journal = {Software and Systems Modeling},
	keywords = {Software modeling, Practitioners, Software assistant, Interviews},
	month = {feb},
	number = 1,
	page = {103–135},
	publisher = {Springer},
	title = {Understanding the need for assistance in software modeling: interviews with experts},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-023-01104-6},
	volume = 23,
	year = 2024
}


@article{10.1007/s10270-022-01076-z,
	abstract = {Despite the amount of proposed works for the verification of embedded systems, understanding the root cause of violations of requirements in simulation or execution traces is still an open issue, especially when dealing with temporal properties such as latencies. Is the violation due to an unfavorable real-time scheduling, to contentions on buses, to the characteristics of functional algorithms or hardware components? The paper introduces the Precise Latency ANalysis approach (PLAN), a new trace analysis technique whose objective is to classify execution transactions according to their impact on latency. To do so, we rely first on a model transformation that builds up a dependency graph from an allocation model, thus including hardware and software aspects of a system model. Then, from this graph and an execution trace, our analysis can highlight how software or hardware elements contributed to the latency violation. The paper first formalizes the problem before applying our approach to simulation traces of SysML models. A case study defined in the AQUAS European project illustrates the relevance of our approach. Last, a performance evaluation gives computation times for several models and requirements.},
	author = {Maysam Zoor and Ludovic Apvrille and Renaud Pacalet and Sophie Coudert},
	doi = {10.1007/s10270-022-01076-z},
	journal = {Software and Systems Modeling},
	keywords = {Embedded systems, Execution trace analysis, Dependency graph, Model-based systems engineering (MBSE), Timing analysis, Simulation},
	month = {oct},
	number = 5,
	page = {1519–1541},
	publisher = {Springer},
	title = {Execution trace analysis for a precise understanding of latency violations},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01076-z},
	volume = 22,
	year = 2023
}

@article{10.1007/s10270-021-00950-6,
	abstract = {Modern software systems are intricate and operate in highly dynamic environments for which few assumptions can be made at design-time. This setting has sparked an interest in solutions that use a runtime model which reflects the system state and operational context to monitor and adapt the system in reaction to changes during its runtime. Few solutions focus on the evolution of the model over time, i.e., its history, although history is required for monitoring temporal behaviors and may enable more informed decision-making. One reason is that handling the history of a runtime model poses an important technical challenge, as it requires tracing a part of the model over multiple model snapshots in a timely manner. Additionally, the runtime setting calls for memory-efficient measures to store and check these snapshots. Following the common practice of representing a runtime model as a typed attributed graph, we introduce a language which supports the formulation of temporal graph queries, i.e., queries on the ordering and timing in which structural changes in the history of a runtime model occurred. We present a querying scheme for the execution of temporal graph queries over history-aware runtime models. Features such as temporal logic operators in queries, the incremental execution, the option to discard history that is no longer relevant to queries, and the in-memory storage of the model, distinguish our scheme from relevant solutions. By incorporating temporal operators, temporal graph queries can be used for runtime monitoring of temporal logic formulas. Building on this capability, we present an implementation of the scheme that is evaluated for runtime querying, monitoring, and adaptation scenarios from two application domains.},
	author = {Lucas Sakizloglou and Sona Ghahremani and Matthias Barkowsky and Holger Giese},
	doi = {10.1007/s10270-021-00950-6},
	journal = {Software and Systems Modeling},
	keywords = {Runtime models, History-awareness, Historic data, Temporal graph queries, Incremental pattern matching, Runtime monitoring, Self-adaptive systems},
	month = {oct},
	number = 5,
	page = {1789–1829},
	publisher = {Springer},
	title = {Incremental execution of temporal graph queries over runtime models with history and its applications},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-021-00950-6},
	volume = 21,
	year = 2022
}


@article{10.1007/s10270-022-01027-8,
	abstract = {Container orchestration tools supporting infrastructure-as-code allow new forms of collaboration between developers and operatives. Still, their text-based nature permits naive mistakes and is more difficult to read as complexity increases. We can find few examples of low-code approaches for defining the orchestration of containers, and there seems to be a lack of empirical studies showing the benefits and limitations of such approaches. We hypothesize that a complete visual notation for Docker-based orchestrations could reduce the effort, the error rate, and the development time. Therefore, we developed a tool featuring such a visual notation for Docker Compose configurations, and we empirically evaluated it in a controlled experiment with novice developers. The results show a significant reduction in development time and error-proneness when defining Docker Compose files, supporting our hypothesis. The participants also thought the prototype easier to use and useful, and wanted to use it in the future.},
	author = {Bruno Piedade and João Pedro Dias and Filipe F. Correia},
	doi = {10.1007/s10270-022-01027-8},
	journal = {Software and Systems Modeling},
	keywords = {Container orchestrations, Infrastructure as code, Empirical study, Visual programming, Docker, Docker Compose},
	month = {oct},
	number = 5,
	page = {1983–2005},
	publisher = {Springer},
	title = {Visual notations in container orchestrations: an empirical study with Docker Compose},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-022-01027-8},
	volume = 21,
	year = 2022
}

@article{10.1007/s10270-021-00949-z,
	abstract = {Regulators are under constant pressure to demonstrate if and how the regulations they administer, which impose many requirements on various systems and processes, achieve intended societal outcomes. Traditionally, regulators have relied on impact assessments, risk analysis, and cost–benefit analysis to assess compliance with regulations. These methods, however, are effort and time intensive and focus on the efficiency of regulatory processes rather than on the effectiveness of the regulatory initiatives meant to improve compliance to regulations and the latter’s impact on intended societal outcomes. Goal-oriented modelling and data analytics approaches provide the basis for the development of more sophisticated methods and tools to better address the needs of regulators. This paper introduces the goal-oriented regulatory intelligence method (GoRIM), which enables effective management of regulations through modelling and data analytics. Through continuous monitoring, assessing, and reporting on efficiency and effectiveness aspects, GoRIM is meant to facilitate the analysis of feedback loops between regulations, regulatory initiatives, and societal outcomes. To demonstrate the applicability and perceived usefulness of GoRIM in addressing the first feedback loop between regulations and initiatives, we evaluated it through three case studies involving regulators from different contexts, with positive results. GoRIM extends the concept of regulatory intelligence beyond the analysis of compliance. It also provides practical guidelines and tools to regulators for making, in a timely way, evidence-based decisions related to the addition, modification, or repeal of regulations and related regulatory initiatives. In addition, GoRIM helps better identify software and information needs for enabling such decisions.},
	author = {Okhaide Akhigbe and Daniel Amyot and Gregory Richards and Lysanne Lessard},
	doi = {10.1007/s10270-021-00949-z},
	journal = {Software and Systems Modeling},
	keywords = {Data analytics, Evidence-based decision-making, Goal-oriented modelling, GRL, Regulations modelling, Regulatory intelligence},
	month = {aug},
	number = 4,
	page = {1613–1641},
	publisher = {Springer},
	title = {GoRIM: a model-driven method for enhancing regulatory intelligence},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-021-00949-z},
	volume = 21,
	year = 2022
}

@article{10.1007/s10270-024-01228-3,
	abstract = {MDE enables the centrality of the models in semi-automated development processes. However, its level of usage in industrial settings is still not adequate for the benefits MDE can introduce. This paper proposes a semi-automatic approach for the completion of high-level models in the lifecycle of critical systems, which exhibit an event-driven behaviour. The proposal suggests a specification guideline that starts from a partial SysML model of a system and on a set of requirements, expressed in the well-known Given–When–Then paradigm. On the basis of such requirements, the approach enables the semi-automatic generation of new SysML state machines model elements. Accordingly, the approach focuses on the completion of the state machines by adding proper transitions (with triggers, guards and effects) among pre-existing states. Also, traceability modelling elements are added to the model. Two case studies demonstrate the feasibility of the proposed approach.},
	author = {Maria Stella de Biase and Simona Bernardi and Stefano Marrone and José Merseguer and Angelo Palladino},
	doi = {10.1007/s10270-024-01228-3},
	journal = {Software and Systems Modeling},
	keywords = {Behaviour-driven development, Requirements engineering, SysML, Critical systems design, Event-driven systems design},
	month = {dec},
	number = 6,
	page = {1455–1491},
	publisher = {Springer},
	title = {Completion of SysML state machines from Given–When–Then requirements},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-024-01228-3},
	volume = 23,
	year = 2024
}

@inproceedings{10.1007/978-3-031-50974-2_11,
	abstract = {Process monitoring and conformance checking analyze process events describing process executions. However, such events are not always available or in a form suitable for these analysis tasks, for example for manual processes and (semi-)automated processes whose executions are not controlled by a Process-Aware Information System. To bridge this gap, we propose to leverage Internet of Things (IoT) technologies for sensing low-level events and abstracting them into high-level process events to enable process monitoring and conformance checking. We propose an event-centric metamodel for monitoring and conformance checking systems that is agnostic with respect to process characteristics such as level of automation, system support, and modeling paradigm. We demonstrate the applicability of the metamodel by instantiating it for processes represented by different modeling paradigms.},
	author = {Marco Franceschetti and Ronny Seiger and Barbara Weber},
	booktitle = {Business Process Management Workshops},
	doi = {10.1007/978-3-031-50974-2_11},
	keywords = {Process monitoring, Conformance checking, IoT},
	month = {jan},
	publisher = {Springer},
	title = {An Event-Centric Metamodel for IoT-Driven Process Monitoring and Conformance Checking},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-50974-2_11},
	year = 2024
}

@inproceedings{10.1007/978-3-031-66326-0_25,
	abstract = {Quantifying and long-term monitoring of the energy consumption of software in end-user computers is a complex task. It brings multiple technical and sociological challenges. End users need to visualize their energy consumption and get a per-software feedback about their energy impact to adapt their software usage towards a greener approach. In this paper, we present our monitoring and feedback architecture: Demeter. Our distributed approach monitors energy consumption per application on runtime, provides end users with immediate feedback through a graphical user interface, and delayed feedback through an analysis email notification. We illustrate our approach with a two-week study of software usage of three different user profiles in a corporate environment.},
	author = {Lylian Siffre and Gabriel Breuil and Adel Noureddine and Renaud Pawlak},
	booktitle = {Software Architecture. ECSA 2023 Tracks, Workshops, and Doctoral Symposium},
	doi = {10.1007/978-3-031-66326-0_25},
	keywords = {Power Monitoring, Measurement, Energy Consumption, Long-term monitoring, Distributed Architecture, Software Engineering},
	month = {jan},
	publisher = {Springer},
	title = {Demeter: An Architecture for Long-Term Monitoring of Software Power Consumption},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/978-3-031-66326-0_25},
	year = 2024
}

@article{10.1007/s10270-021-00950-6,
	abstract = {Modern software systems are intricate and operate in highly dynamic environments for which few assumptions can be made at design-time. This setting has sparked an interest in solutions that use a runtime model which reflects the system state and operational context to monitor and adapt the system in reaction to changes during its runtime. Few solutions focus on the evolution of the model over time, i.e., its history, although history is required for monitoring temporal behaviors and may enable more informed decision-making. One reason is that handling the history of a runtime model poses an important technical challenge, as it requires tracing a part of the model over multiple model snapshots in a timely manner. Additionally, the runtime setting calls for memory-efficient measures to store and check these snapshots. Following the common practice of representing a runtime model as a typed attributed graph, we introduce a language which supports the formulation of temporal graph queries, i.e., queries on the ordering and timing in which structural changes in the history of a runtime model occurred. We present a querying scheme for the execution of temporal graph queries over history-aware runtime models. Features such as temporal logic operators in queries, the incremental execution, the option to discard history that is no longer relevant to queries, and the in-memory storage of the model, distinguish our scheme from relevant solutions. By incorporating temporal operators, temporal graph queries can be used for runtime monitoring of temporal logic formulas. Building on this capability, we present an implementation of the scheme that is evaluated for runtime querying, monitoring, and adaptation scenarios from two application domains.},
	author = {Lucas Sakizloglou and Sona Ghahremani and Matthias Barkowsky and Holger Giese},
	doi = {10.1007/s10270-021-00950-6},
	journal = {Software and Systems Modeling},
	keywords = {Runtime models, History-awareness, Historic data, Temporal graph queries, Incremental pattern matching, Runtime monitoring, Self-adaptive systems},
	month = {oct},
	number = 5,
	page = {1789–1829},
	publisher = {Springer},
	title = {Incremental execution of temporal graph queries over runtime models with history and its applications},
	url = {http://link.springer.com/openurl/pdf?id=doi:10.1007/s10270-021-00950-6},
	volume = 21,
	year = 2022
}